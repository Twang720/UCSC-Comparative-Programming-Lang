#!/usr/bin/perl
# Timothy Wang tqwang@ucsc.edu
# Eric Mar emmar@ucsc.edu
use strict;
use warnings;
use diagnostics;
use Getopt::Std;

my %strsignal = (
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   11 => "Segmentation fault",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

my %macro_table;
my %target_table;
my %command_table;
my @macros;
my @targets;
my $last_target;

# mtime.perl subroutines to find time
#sub mtime ($) {
#    my ($filename) = @_;
#   my @stat = stat $filename;
#   return @stat ? $stat[9] : undef;
#}

#sub fileinfo ($) {
#   my ($filename) = @_;
#   my $mtime = mtime $filename;
#   print "$filename: ";
#   if (defined $mtime) {print strftime "%c\n", localtime $mtime}
#   else {print "$!\n"}
#   return $mtime;
#}

#read inputs
open(my $fh, '<', "Makefile") or die "Can't open < Makefile: $!";
while (my $line = <$fh>) {
    chomp($line);
    my $ishash = substr($line, 0, 1);
    if (($ishash ne "#")) {
        if ($line =~ /\t(.*)$/) {
            my $array = $command_table{$last_target};
            push @$array, $1;
            $command_table{$last_target} = $array;
        } elsif ($line =~ /=/) {
            push @macros, $line;
        } elsif ($line =~ m/^(\S+)\s*:\s*(.*?)\s*$/) {
            # need to store first target seperately for case of no args
            # implement time stamps and % handling
            push @targets, $line;
            $last_target = $1;
        }
    }
}
close $fh;

# split macros
sub parse_macros {
    my ($line) = @_;
    return undef unless $line =~ m/^(\S+)\s*=\s*(.*?)\s*$/;
    my ($macro, $value) = ($1, $2);
    my @values = split m/\s+/, $value;
    return $macro, \@values;
}

for my $m (@macros) {
    my ($var, $val) = parse_macros $m;
    print "$0: syntax error: $m\n" and next unless defined $var;
    $macro_table{$var} = $val;
}

# split dependencies
sub parse_dep {
    my ($line) = @_;
    return undef unless $line =~ m/^(\S+)\s*:\s*(.*?)\s*$/;
    my ($target, $dependency) = ($1, $2);
    my @dependencies = split m/\s+/, $dependency;
    $target = unpacker($target);
    my @deps;
    for my $d (@dependencies) {
        push(@deps, unpacker($d));
    }
    return $target, \@deps;
}

for my $t (@targets) {
    my ($target, @deps) = parse_dep $t;
    print "$0: syntax error: $t\n" and next unless defined $target;
    $target_table{$target} = \@deps;
}

# replace macros, recursively if needed
sub unpacker {
    my ($macro) = @_;
    my @results;
    if(substr ($macro, 0, 1) ne "\$") {
        return $macro;
    }
    elsif (substr ($macro, 1, 1) eq "\$") {
        return \$;
    }
    #elsif (substr ($macro, 1, 1) eq "<") {
    #   return $dependency;
    #}
    #elsif (substr ($macro, 1, 1) eq "@") {
    #   return $target;
    #}
    else
    {
        my $temp = substr($macro, 2, (length($_)-3));
        my $value = $macro_table{$temp};
        foreach my $v (@$value) {
            push(@results, unpacker ($v));
        }
    }
    return @results;
}

# split commands and replace macros
sub parse_commands {
    my ($line) = @_;
    my @words = split m/\s+/, $line;
    my @new_cmd;
    for (@words)
    {
        push @new_cmd, unpacker($_);
    }
    return join(" ", @new_cmd);
}

# execute commands
for my $target (keys %command_table)
{
    # check to make sure that @ is not first char
    my $values = $command_table{$target};
    for (@$values) {
        my $cmd = parse_commands $_;
        print "$cmd\n";
        system $cmd;
    }
    
    my $term_signal = $? & 0x7F;
    my $core_dumped = $? & 0x80;
    my $exit_status = ($? >> 8) & 0xFF;
    # also check to make sure - is not first char
    if($exit_status != 0)
    {
        die "[Makefile: $target] Error $exit_status";
    }
}
