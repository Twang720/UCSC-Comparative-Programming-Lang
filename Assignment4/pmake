#!/usr/bin/perl
# Timothy Wang tqwang@ucsc.edu
# Eric Mar emmar@ucsc.edu
use strict;
use warnings;
use diagnostics;
use Getopt::Std;

my %strsignal = (
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   11 => "Segmentation fault",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

$0 =~ s|^(.*/)?([^/]+)/*$|$2|;
my $EXITCODE = 0;
END{ exit $EXITCODE; }
sub note(@) { print STDERR "$0: @_"; };
$SIG{'__WARN__'} = sub { note @_; $EXITCODE = 1; };
$SIG{'__DIE__'} = sub { warn @_; exit; };

(my $USAGE = <<__END_USAGE__) =~ s/^#[ ]?//gm;
__END_USAGE__

my %OPTS;
getopts ("abcho:p:q:", \%OPTS);
print $USAGE and exit if $OPTS{'h'};

print "$0: -$_ = $OPTS{$_}\n" for sort keys %OPTS;
print "$0: ARGV[$_]=$ARGV[$_]\n" for 0 .. $#ARGV;

my $term_signal = $? & 0x7F;
my $core_dumped = $? & 0x80;
my $exit_status = ($? >> 8) & 0xFF;

#read inputs
open(my $fh, '<', "Makefile")
    or die "Can't open < Makefile: $!";

my @input;
while(my $line = <$fh>){
    chomp($line);
    
    push @input, $line;
}

sub parse_macros ($) {
    my ($line) = @_;
    return undef unless $line =~ m/^(\S+)\s*=\s*(.*?)\s*$/;
    my ($macro, $definition) = ($1, $2);
    my @definitions = split m/\s+/, $definition;
    for($i = 0; $i < @definitions; $i++)
    {
        if(substr (@definitions[$i], 0, 1) eq \$)
        {
            my $temp;
            ($temp, @definitions[$i]) = parse_macros(@definitions[$i]);
        }
    }
    return $macro, \@definitions;
}

my %macros;
for my $m (@macro) {
    my ($var, $val) = parse_macros $m;
    print "$0: syntax error: $input\n" and next unless defined $var;
    $macros{$var} = $val;
}

sub parse_dep ($) {
    my ($line) = @_;
    return undef unless $line =~ m/^(\S+)\s*:\s*(.*?)\s*$/;
    my ($target, $dependency) = ($1, $2);
    my @dependencies = split m/\s+/, $dependency;
    if(substr ($target, 0, 1) eq \$)
    {
        my $temp = substr $target, 2, (length $target) - 3;
        $target = $macros{$temp};
    }
    for my @dep (@dependencies) {
        if(substr (@dep[0], 0, 1) eq \$)
        {
            my $temp = substr $dep, 2, (length $dep) - 3;
            @dep = $macros{$temp};
        }
    }
    return $target, \@dependencies;
}

my %targets;
for my $input (@inputs) {
   my ($target, $deps) = parse_dep $input;
   print "$0: syntax error: $input\n" and next unless defined $target;
   $targets{$target} = $deps;
}



